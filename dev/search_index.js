var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = StringAlgorithms","category":"page"},{"location":"#StringAlgorithms","page":"Home","title":"StringAlgorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for StringAlgorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [StringAlgorithms]","category":"page"},{"location":"#StringAlgorithms.PalindromicAutomaton-Union{Tuple{}, Tuple{T}} where T","page":"Home","title":"StringAlgorithms.PalindromicAutomaton","text":"Create an empty palindromic automaton of key type T.\n\nThe Palindromic AutoMaton (PAM, also known as the palindrome tree) is a very useful data structure for solving palindrome-related problems. A detailed introduction to PAM can be found via:\n\nWikipedia: Palindrome Tree\nOI-Wiki: 回文树\n\nTo add new values into the automaton, simply use Base.push!.\n\nGetters for the internal fields of the automaton are provided, including:\n\nchildren(pam): Get the children dictionary of the PAM.\nnodecount(pam): Get the number of nodes in the PAM.\nlastnodeindex(pam): Get the index of the last node of the PAM.\nlen(pam, i): Get the palindrome length of the i-th node.\nfail(pam, i): Get the fail pointer of the i-th node.\ncnt(pam, i): Get the frequency count of the i-th node. \n\nSample usages\n\nFinding the length of the longest palindromic substring\n\nfunction longest_palindromic_substring(s)\n    pam = PalindromicAutomaton{Char}()\n    hi = 0\n    for ch in s\n        push!(pam, ch)\n        hi = max(hi, len(pam, lastnodeindex(pam)))\n    end\n    return hi\nend\n\nlongest_palindromic_substring(\"ddabababacc\")\n\n# output\n\n7\n\n\n\n\n\n","category":"method"},{"location":"#StringAlgorithms.PrefixAutomaton-Union{Tuple{T}, Tuple{Any, Any}} where T","page":"Home","title":"StringAlgorithms.PrefixAutomaton","text":"Build an automaton based on the prefix function of a given vector and a fixed alphabet. This is useful when the vector to be searched within is very large.\n\n\n\n\n\n","category":"method"},{"location":"#StringAlgorithms.SuffixAutomaton-Union{Tuple{}, Tuple{T}} where T","page":"Home","title":"StringAlgorithms.SuffixAutomaton","text":"Create an empty suffix automaton of key type T.\n\nThe Suffix AutoMaton (SAM) is a very useful data structure for solving string-related problems. A detailed introduction to SAM can be found via:\n\nWikipedia: Suffix Automaton\nOI-Wiki: 后缀自动机\n\n\n\n\n\n","category":"method"},{"location":"#Base.findall-Tuple{Any, SuffixAutomaton, Any}","page":"Home","title":"Base.findall","text":"findall(pattern, sam, invlink; ascending)\n\n\nFind all matches of a given pattern (including overlapping ones) in a suffix automaton, with the help of precalculated inverse links.\n\nIf the keyword argument ascending is set to true, the results will be sorted in place in the ascending order. Otherwise, the results will be unordered.\n\nIf you need to perform multiple searches on the same text, this function can be much faster than Julia standard library's implementation, especially when the pattern is long but does not occur in the string to be searched. \n\njulia> sam = SuffixAutomaton(\"abcdabdabcddabcabdab\");\n\njulia> invlink = inverselink(sam);\n\njulia> findall(\"ab\", sam, invlink; ascending=true)\n6-element Vector{UnitRange{Int64}}:\n 1:2\n 5:6\n 8:9\n 13:14\n 16:17\n 19:20\n\njulia> findall(\"da\", sam, invlink; ascending=true)\n4-element Vector{UnitRange{Int64}}:\n 4:5\n 7:8\n 12:13\n 18:19\n\n\n\n\n\n","category":"method"},{"location":"#StringAlgorithms.inverselink-Tuple{SuffixAutomaton}","page":"Home","title":"StringAlgorithms.inverselink","text":"inverselink(sam)\n\n\nBuild an inverse graph from the links of a suffix automaton.\n\n\n\n\n\n","category":"method"},{"location":"#StringAlgorithms.longestcommonsubstring-Tuple","page":"Home","title":"StringAlgorithms.longestcommonsubstring","text":"longestcommonsubstring(args; lengthonly)\n\n\nFind the longest common non-empty substring/sub-vector of multiple strings/vectors. \n\nWhen there are more than one with the same length, all distinct answers will be returned in a nondeterministic order.\n\njulia> longestcommonsubstring(\"ababab\", \"bababa\", \"abaabb\")\n1-element Vector{String}:\n \"aba\"\n\n\n\n\n\n","category":"method"},{"location":"#StringAlgorithms.manacher-Tuple{Any}","page":"Home","title":"StringAlgorithms.manacher","text":"manacher(v)\n\n\nThe Manacher algorithm proposed by Glenn K. Manacher in 1975.\n\nGiven a vector of length n, so that there will be 2n+1 positions if the intervals between each element are included, returns a vector of length 2n+1 denoting the longest palindrome centered at each position.\n\nSample usages\n\nFinding the length of the longest palindromic substring\n\nfunction longest_palindromic_substring(s)\n    return maximum(manacher(s))\nend\n\nlongest_palindromic_substring(\"ddabababacc\")\n\n# output\n\n7\n\n\n\n\n\n","category":"method"},{"location":"#StringAlgorithms.maximumrotation-Tuple{Any}","page":"Home","title":"StringAlgorithms.maximumrotation","text":"maximumrotation(s)\n\n\nFind the maximum of all rotations of the given string/vector.\n\nFor example, string aab has three rotations:, aab, aba, baa, and baa is the maximum rotation.\n\njulia> maximumrotation(\"aab\")\n\"baa\"\n\n\n\n\n\n","category":"method"},{"location":"#StringAlgorithms.minimumrotation-Tuple{Any}","page":"Home","title":"StringAlgorithms.minimumrotation","text":"minimumrotation(s)\n\n\nFind the minimum of all rotations of the given string/vector. \n\nFor example, string aab has three rotations:, aab, aba, baa, and aab is the minimum rotation.\n\njulia> minimumrotation(\"aab\")\n\"aab\"\n\n\n\n\n\n","category":"method"},{"location":"#StringAlgorithms.nodeoriented-Union{Tuple{SuffixAutomaton{T}}, Tuple{T}} where T","page":"Home","title":"StringAlgorithms.nodeoriented","text":"Transform the internal representation of the suffix automaton into a more user-friendly node-oriented representation, which might be useful when users want to access some internal information.\n\n\n\n\n\n","category":"method"},{"location":"#StringAlgorithms.prefix_function-Tuple{Any}","page":"Home","title":"StringAlgorithms.prefix_function","text":"prefix_function(v)\n\n\nFor each prefix of the given vector, calculate the maximum length such that its nontrivial prefix (not itself) equals to its suffix.\n\nFor example, for string ababc,\n\np[1] = 0\np[2] = 0\np[3] = 1, since the prefix aba has both prefix a and suffix a\np[4] = 2, since the prefix abab has both prefix ab and suffix ab\np[5] = 0\n\nSample usages\n\nFinding all matches (KMP algorithm)\n\n# The following function finds all occurrences of the pattern in the given vector, including overlapping ones.\nfunction findall(pattern, s)\n    n, m = length(s), length(pattern)\n    tmp = vcat(collect(pattern), [nothing], collect(s))\n    p = prefix_function(tmp)\n    return [i-m+1:i for i in 1:n if p[i+m+1] == m]\nend\n\nfindall(\"aba\", \"ddabababacc\")\n\n# output\n\n3-element Vector{UnitRange{Int64}}:\n 3:5\n 5:7\n 7:9\n\n\n\n\n\n","category":"method"},{"location":"#StringAlgorithms.toposort-Tuple{SuffixAutomaton}","page":"Home","title":"StringAlgorithms.toposort","text":"toposort(sam)\n\n\nFind the topological order of all nodes in a suffix automaton.\n\n\n\n\n\n","category":"method"},{"location":"#StringAlgorithms.z_algorithm-Tuple{Any}","page":"Home","title":"StringAlgorithms.z_algorithm","text":"z_algorithm(v)\n\n\nZ Algorithm calculates the longest common prefix of each suffix of the given vector and the whole vector itself. Specially, the Z value of the whole vector is forced to be 0.\n\nSample usages\n\nUsages of Z Algorithm are almost the same as the prefix function.\n\nFinding all matches\n\n# The following function finds all occurrences of the pattern in the given vector, including overlapping ones.\nfunction findall(pattern, s)\n    n, m = length(s), length(pattern)\n    tmp = vcat(collect(pattern), [nothing], collect(s))\n    z = z_algorithm(tmp)\n    return [i:i+m-1 for i in 1:n if z[i+m+1] == m]\nend\n\nfindall(\"aba\", \"ddabababacc\")\n\n# output\n\n3-element Vector{UnitRange{Int64}}:\n 3:5\n 5:7\n 7:9\n\n\n\n\n\n","category":"method"}]
}
